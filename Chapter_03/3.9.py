"""
    dict 和 set 的背后
    1.
    Python 里的 dict 和 set 的效率有多高？

    2.
    为什么它们是无序的？

    3.
    为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素

    4.
    为什么 dict 的键和 set 元素的顺序是根据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序不一定是一成不变的？

    5.
    为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？

    6.
    散列表是一个稀疏数组(总有空白元素的数组称为稀疏数组)。散列表里的单元称为表元(bucket)。
    在 dict 的散列表中，每个键值对都占用一个表元，每个表元都有两个部分，一个对键的引用，一个对值的引用。
    因为表元大小一致，所以可以通过偏移量来读取某个表元。
    Python 会保证大概有三分之一的表元是空的，所以在快要达到这个阈值时，原有散列表会被复制到一个更大的空间里。
    如果要把一个对象放入散列表，首先要计算这个元素的散列值。可以使用 hash() 方法

    7.
    内置的 hash() 方法可以用于所有内置类型对象，自定义对象调用 hash() 方法实际是运行 __hash__() 魔法函数。
    在比较两个对象是否相等时，必需比较散列值是否相等。

    8.
    如果 search_key 与 found_key 不匹配，则称为散列冲突。

    9.
    dict 的实现及其导致的结果
    - 键必须是可散列的：支持 __hash__() 方法；支持 __eq__() 方法，若 a == b 则 hash(a) == bash(b)；用户自定义的对象默认都是可散列的，散列函数为 id()
    - 字典在内存上开销巨大
    - 键查询很快
    - 键的次序取决于添加顺序
    - 往字典里添加新键可能会改变已有键的顺序：
        添加元素时可能出现字典扩容，扩容的结果就是新建一个更大的散列表，并把字典里的已有元素添加到新表里，这个过程可能会发生新的散列冲突，导致新散列表中键的次序变化。
"""
